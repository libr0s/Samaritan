'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = parseCLDR;
// import { isEqual } from 'lodash'

// The generic time measurement units.
// (other units like "fri" or "thu" are ignored)
// ("quarter" is required by `Intl.RelativeTimeFormat`)
var units = exports.units = ['second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'];

// Detects short and narrow flavours of labels (yr., mo., etc).
// E.g. there are "month", "month-short", "month-narrow".
// More on "narrow" vs "short":
// http://cldr.unicode.org/translation/plurals#TOC-Narrow-and-Short-Forms
var short = /-short$/;
var narrow = /-narrow$/;

// Converts locale data from CLDR format to this library's format.
//
// CLDR locale data example:
//
// ```json
// {
//   "main": {
//     "en-US-POSIX": {
//       "identity": {
//         "language": "en",
//         ...
//       },
//       "dates": {
//         "fields": {
//           "year": {
//             "displayName": "year",
//             "relative-type--1": "last year",
//             "relative-type-0": "this year",
//             "relative-type-1": "next year",
//             "relativeTime-type-future": {
//               "relativeTimePattern-count-one": "in {0} year",
//               "relativeTimePattern-count-other": "in {0} years"
//             },
//             "relativeTime-type-past": {
//               "relativeTimePattern-count-one": "{0} year ago",
//               "relativeTimePattern-count-other": "{0} years ago"
//             }
//           },
// ...
// ```
//
// Parsed locale data example:
//
// ```json
// {
// 	"long":
// 	{
// 		...
// 		"second": [
// 			{
// 				"one": "a second ago",
// 				"other": "{0} seconds ago"
// 			},
// 			{
// 				"one": "in a second",
// 				"other": "in {0} seconds"
// 			}
// 		],
// 		...
// 	},
// 	"short":
// 	{
// 		...
// 	},
// 	...
// }
// ```
function parseCLDR(data) {
	// Extract `locale` from CLDR data
	var locale = Object.keys(data.main)[0];
	var timeUnitsFormattingRules = data.main[locale].dates.fields;

	return Object.keys(timeUnitsFormattingRules).filter(function (unit) {
		// Take only the generic time measurement units
		// (skip exotic ones like "fri" on "thu").
		return units.indexOf(parseUnit(unit).unit) >= 0;
	}).reduce(function (localeData, _unit) {
		var _parseUnit = parseUnit(_unit),
		    unit = _parseUnit.unit,
		    type = _parseUnit.type;

		return setUnitRules(localeData, type, unit, parseCLDRTimeUnitFormattingRules(timeUnitsFormattingRules[_unit]));
	},
	// Parsed locale data
	{});
}

/**
 * Parses CLDR time unit formatting rules.
 * @param  {object} - CLDR time unit formatting rules.
 * @return {(object|string)}
 */
function parseCLDRTimeUnitFormattingRules(rulesCLDR) {
	var rules = {};

	// "relative" values aren't suitable for "ago" or "in a" cases,
	// because "1 year ago" != "last year" (too vague for Jan 30th)
	// and "in 0.49 years" != "this year" (it could be Nov 30th).
	// Still including them here for `Intl.RelativeTimeFormat` polyfill.

	// "yesterday"
	if (rulesCLDR['relative-type--1']) {
		rules.previous = rulesCLDR['relative-type--1'];
	}

	// "today"
	/* istanbul ignore else */
	if (rulesCLDR['relative-type-0']) {
		rules.current = rulesCLDR['relative-type-0'];
	}

	// "tomorrow"
	if (rulesCLDR['relative-type-1']) {
		rules.next = rulesCLDR['relative-type-1'];
	}

	// Formatting past times.
	//
	// E.g.:
	//
	// "relativeTime-type-past":
	// {
	// 	"relativeTimePattern-count-one": "{0} mo. ago",
	// 	"relativeTimePattern-count-other": "{0} mo. ago"
	// }
	//
	/* istanbul ignore else */
	if (rulesCLDR['relativeTime-type-past']) {
		var past = rulesCLDR['relativeTime-type-past'];
		rules.past = {};

		// Populate all quantifiers ("one", "other", etc).
		for (var _iterator = Object.keys(past), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
			var _ref;

			if (_isArray) {
				if (_i >= _iterator.length) break;
				_ref = _iterator[_i++];
			} else {
				_i = _iterator.next();
				if (_i.done) break;
				_ref = _i.value;
			}

			var quantifier = _ref;

			rules.past[quantifier.replace('relativeTimePattern-count-', '')] = past[quantifier];
		}

		// Delete all duplicates of "other" rule.
		for (var _iterator2 = Object.keys(rules.past), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
			var _ref2;

			if (_isArray2) {
				if (_i2 >= _iterator2.length) break;
				_ref2 = _iterator2[_i2++];
			} else {
				_i2 = _iterator2.next();
				if (_i2.done) break;
				_ref2 = _i2.value;
			}

			var _quantifier = _ref2;

			if (_quantifier !== 'other' && rules.past[_quantifier] === rules.past.other) {
				delete rules.past[_quantifier];
			}
		}

		// If only "other" rule is present then "rules" is not an object and is a string.
		if (Object.keys(rules.past).length === 1) {
			rules.past = rules.past.other;
		}
	}

	// Formatting future times.
	//
	// E.g.:
	//
	// "relativeTime-type-future":
	// {
	// 	"relativeTimePattern-count-one": "in {0} mo.",
	// 	"relativeTimePattern-count-other": "in {0} mo."
	// }
	//
	/* istanbul ignore else */
	if (rulesCLDR['relativeTime-type-future']) {
		var future = rulesCLDR['relativeTime-type-future'];
		rules.future = {};

		// Populate all quantifiers ("one", "other", etc).
		for (var _iterator3 = Object.keys(future), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
			var _ref3;

			if (_isArray3) {
				if (_i3 >= _iterator3.length) break;
				_ref3 = _iterator3[_i3++];
			} else {
				_i3 = _iterator3.next();
				if (_i3.done) break;
				_ref3 = _i3.value;
			}

			var _quantifier2 = _ref3;

			rules.future[_quantifier2.replace('relativeTimePattern-count-', '')] = future[_quantifier2];
		}

		// Delete all duplicates of "other" rule.
		for (var _iterator4 = Object.keys(rules.future), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
			var _ref4;

			if (_isArray4) {
				if (_i4 >= _iterator4.length) break;
				_ref4 = _iterator4[_i4++];
			} else {
				_i4 = _iterator4.next();
				if (_i4.done) break;
				_ref4 = _i4.value;
			}

			var _quantifier3 = _ref4;

			if (_quantifier3 !== 'other' && rules.future[_quantifier3] === rules.future.other) {
				delete rules.future[_quantifier3];
			}
		}

		// If only "other" rule is present then "rules" is not an object and is a string.
		if (Object.keys(rules.future).length === 1) {
			rules.future = rules.future.other;
		}
	}

	// // If `.past` === `.future` then replace them with `.other`.
	// // (only eligible for "tiny" and "*-time" locale data which is not part of CLDR)
	// if (isEqual(rules.past, rules.future)) {
	// 	rules.other = rules.past
	// 	delete rules.future
	// }

	// // If only "other" rule is defined for a time unit
	// // then make "rules" a string rather than an object.
	// if (Object.keys(rules).length === 1) {
	// 	rules = rules.other
	// }

	return rules;
}

/**
 * Sets time unit formatting rules in locale data.
 * @param {object} localeData
 * @param {string} type
 * @param {string} unit
 * @param {object} rules
 * @return {object} Locale data.
 */
function setUnitRules(localeData, type, unit, rules) {
	if (!localeData[type]) {
		localeData[type] = {};
	}

	localeData[type][unit] = rules;

	// Populate "now" unit rules.
	if (unit === 'second' && rules.current) {
		localeData[type].now = rules.current;
	}

	return localeData;
}

/**
 * Parses CLDR time unit into `unit` and `type`.
 * @param  {string} CLDR_unit
 * @return {object} `{ type, unit }`.
 */
function parseUnit(unit) {
	if (narrow.test(unit)) {
		return { type: 'narrow', unit: unit.replace(narrow, '') };
	}
	if (short.test(unit)) {
		return { type: 'short', unit: unit.replace(short, '') };
	}
	return { type: 'long', unit: unit };
}
//# sourceMappingURL=cldr.js.map