{"version":3,"sources":["../source/grade.js"],"names":["grade","elapsed","now","units","gradation","getAllowedSteps","length","i","findGradationStep","step","granularity","amount","Math","round","factor","getThreshold","fromStep","toStep","threshold","id","unit","undefined","type","Error","JSON","stringify","filter","indexOf"],"mappings":";;;;;;;;kBAuBwBA,K;;AAvBxB;;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBe,SAASA,KAAT,CAAeC,OAAf,EAAwBC,GAAxB,EAA6BC,KAA7B,EACf;AAAA,KADmDC,SACnD;;AACC;AACA;AACAA,aAAYC,gBAAgBD,SAAhB,EAA2BD,KAA3B,CAAZ;;AAEA;AACA;AACA,KAAIC,UAAUE,MAAV,KAAqB,CAAzB,EAA4B;AAC3B;AACA;;AAED;AACA,KAAMC,IAAIC,kBAAkBP,OAAlB,EAA2BC,GAA3B,EAAgCE,SAAhC,CAAV;AACA,KAAMK,OAAOL,UAAUG,CAAV,CAAb;;AAEA;AACA;AACA;AACA,KAAIA,MAAM,CAAC,CAAX,EAAc;AACb;AACA;;AAED;AACA;AACA;AACA;AACA,KAAIE,KAAKC,WAAT,EAAsB;AACrB;AACA,MAAMC,SAASC,KAAKC,KAAL,CAAYZ,UAAUQ,KAAKK,MAAhB,GAA0BL,KAAKC,WAA1C,IAAyDD,KAAKC,WAA7E;AACA;AACA;AACA;AACA;AACA,MAAIC,WAAW,CAAX,IAAgBJ,IAAI,CAAxB,EAA2B;AAC1B,UAAOH,UAAUG,IAAI,CAAd,CAAP;AACA;AACD;;AAED,QAAOE,IAAP;AACA;;AAED;;;;;;;;AAQA,SAASM,YAAT,CAAsBC,QAAtB,EAAgCC,MAAhC,EAAwCf,GAAxC,EACA;AACC,KAAIgB,kBAAJ;;AAEA;AACA;AACA,KAAIF,aAAaA,SAASG,EAAT,IAAeH,SAASI,IAArC,CAAJ,EAAgD;AAC/CF,cAAYD,2BAAwBD,SAASG,EAAT,IAAeH,SAASI,IAAhD,EAAZ;AACA;;AAED;AACA;AACA,KAAIF,cAAcG,SAAlB,EAA6B;AAC5BH,cAAYD,OAAOC,SAAnB;AACA;;AAED;AACA,KAAI,OAAOA,SAAP,KAAqB,UAAzB,EAAqC;AACpCA,cAAYA,UAAUhB,GAAV,CAAZ;AACA;;AAED;AACA,KAAIc,YAAY,OAAOE,SAAP,KAAqB,QAArC,EAA+C;AAC9C;AACA;AACA;AACA,MAAMI,cAAcJ,SAAd,yCAAcA,SAAd,CAAN;AACA,QAAM,IAAIK,KAAJ,4FAAmGL,SAAnG,WAAkHI,IAAlH,gBAAiIE,KAAKC,SAAL,CAAeR,MAAf,CAAjI,CAAN;AACA;;AAED,QAAOC,SAAP;AACA;;AAED;;;;;;;AAOA,SAASV,iBAAT,CAA2BP,OAA3B,EAAoCC,GAApC,EAAyCE,SAAzC,EACA;AAAA,KADoDG,CACpD,uEADwD,CACxD;;AACC;AACA;AACA,KAAIN,UAAUc,aAAaX,UAAUG,IAAI,CAAd,CAAb,EAA+BH,UAAUG,CAAV,CAA/B,EAA6CL,GAA7C,CAAd,EAAiE;AAChE,SAAOK,IAAI,CAAX;AACA;AACD;AACA,KAAIA,MAAMH,UAAUE,MAAV,GAAmB,CAA7B,EAAgC;AAC/B,SAAOC,CAAP;AACA;AACD;AACA,QAAOC,kBAAkBP,OAAlB,EAA2BC,GAA3B,EAAgCE,SAAhC,EAA2CG,IAAI,CAA/C,CAAP;AACA;;AAED;;;;;;AAMA,SAASF,eAAT,CAAyBD,SAAzB,EAAoCD,KAApC,EACA;AACC,QAAOC,UAAUsB,MAAV,CAAiB,gBAAc;AAAA,MAAXN,IAAW,QAAXA,IAAW;;AACrC;AACA;AACA,MAAIA,IAAJ,EAAU;AACT,UAAOjB,MAAMwB,OAAN,CAAcP,IAAd,KAAuB,CAA9B;AACA;AACD;AACA;AACA,SAAO,IAAP;AACA,EATM,CAAP;AAUA","file":"grade.js","sourcesContent":["import { convenient } from './gradation'\r\n\r\n/**\r\n * Takes seconds `elapsed` and measures them against\r\n * `gradation` to return the suitable `gradation` step.\r\n *\r\n * @param {number} elapsed - Time interval (in seconds)\r\n *\r\n * @param {string[]} units - A list of allowed time units\r\n *                           (e.g. ['second', 'minute', 'hour', …])\r\n *\r\n * @param {Object} [gradation] - Time scale gradation steps.\r\n *\r\n *                               E.g.:\r\n *                               [\r\n *                                 { unit: 'second', factor: 1 },\r\n *                                 { unit: 'minute', factor: 60, threshold: 60 },\r\n *                                 { format(), threshold: 24 * 60 * 60 },\r\n *                                 …\r\n *                               ]\r\n *\r\n * @return {?Object} `gradation` step.\r\n */\r\nexport default function grade(elapsed, now, units, gradation = convenient)\r\n{\r\n\t// Leave only allowed time measurement units.\r\n\t// E.g. omit \"quarter\" unit.\r\n\tgradation = getAllowedSteps(gradation, units)\r\n\r\n\t// If no steps of gradation fit the conditions\r\n\t// then return nothing.\r\n\tif (gradation.length === 0) {\r\n\t\treturn\r\n\t}\r\n\r\n\t// Find the most appropriate gradation step\r\n\tconst i = findGradationStep(elapsed, now, gradation)\r\n\tconst step = gradation[i]\r\n\r\n\t// If time elapsed is too small and even\r\n\t// the first gradation step doesn't suit it\r\n\t// then return nothing.\r\n\tif (i === -1) {\r\n\t\treturn\r\n\t}\r\n\r\n\t// Apply granularity to the time amount\r\n\t// (and fall back to the previous step\r\n\t//  if the first level of granularity\r\n\t//  isn't met by this amount)\r\n\tif (step.granularity) {\r\n\t\t// Recalculate the elapsed time amount based on granularity\r\n\t\tconst amount = Math.round((elapsed / step.factor) / step.granularity) * step.granularity\r\n\t\t// If the granularity for this step\r\n\t\t// is too high, then fallback\r\n\t\t// to the previous step of gradation.\r\n\t\t// (if there is any previous step of gradation)\r\n\t\tif (amount === 0 && i > 0) {\r\n\t\t\treturn gradation[i - 1]\r\n\t\t}\r\n\t}\r\n\r\n\treturn step\r\n}\r\n\r\n/**\r\n * Gets threshold for moving from `fromStep` to `next_step`.\r\n * @param  {Object} fromStep - From step.\r\n * @param  {Object} next_step - To step.\r\n * @param  {number} now - The current timestamp.\r\n * @return {number}\r\n * @throws Will throw if no threshold is found.\r\n */\r\nfunction getThreshold(fromStep, toStep, now)\r\n{\r\n\tlet threshold\r\n\r\n\t// Allows custom thresholds when moving\r\n\t// from a specific step to a specific step.\r\n\tif (fromStep && (fromStep.id || fromStep.unit)) {\r\n\t\tthreshold = toStep[`threshold_for_${fromStep.id || fromStep.unit}`]\r\n\t}\r\n\r\n\t// If no custom threshold is set for this transition\r\n\t// then use the usual threshold for the next step.\r\n\tif (threshold === undefined) {\r\n\t\tthreshold = toStep.threshold\r\n\t}\r\n\r\n\t// Convert threshold to a number.\r\n\tif (typeof threshold === 'function') {\r\n\t\tthreshold = threshold(now)\r\n\t}\r\n\r\n\t// Throw if no threshold is found.\r\n\tif (fromStep && typeof threshold !== 'number') {\r\n\t\t// Babel transforms `typeof` into some \"branches\"\r\n\t\t// so istanbul will show this as \"branch not covered\".\r\n\t\t/* istanbul ignore next */\r\n\t\tconst type = typeof threshold\r\n\t\tthrow new Error(`Each step of a gradation must have a threshold defined except for the first one. Got \"${threshold}\", ${type}. Step: ${JSON.stringify(toStep)}`)\r\n\t}\r\n\r\n\treturn threshold\r\n}\r\n\r\n/**\r\n * @param  {number} elapsed - Time elapsed (in seconds).\r\n * @param  {number} now - Current timestamp.\r\n * @param  {Object} gradation - Gradation.\r\n * @param  {number} i - Gradation step currently being tested.\r\n * @return {number} Gradation step index.\r\n */\r\nfunction findGradationStep(elapsed, now, gradation, i = 0)\r\n{\r\n\t// If the threshold for moving from previous step\r\n\t// to this step is too high then return the previous step.\r\n\tif (elapsed < getThreshold(gradation[i - 1], gradation[i], now)) {\r\n\t\treturn i - 1\r\n\t}\r\n\t// If it's the last step of gradation then return it.\r\n\tif (i === gradation.length - 1) {\r\n\t\treturn i\r\n\t}\r\n\t// Move to the next step.\r\n\treturn findGradationStep(elapsed, now, gradation, i + 1)\r\n}\r\n\r\n/**\r\n * Leaves only allowed gradation steps.\r\n * @param  {Object[]} gradation\r\n * @param  {string[]} units - Allowed time units.\r\n * @return {Object[]}\r\n */\r\nfunction getAllowedSteps(gradation, units)\r\n{\r\n\treturn gradation.filter(({ unit }) => {\r\n\t\t// If this step has a `unit` defined\r\n\t\t// then this `unit` must be in the list of `units` allowed.\r\n\t\tif (unit) {\r\n\t\t\treturn units.indexOf(unit) >= 0\r\n\t\t}\r\n\t\t// A gradation step is not required to specify a `unit`.\r\n\t\t// E.g. for Twitter gradation it specifies `format()` instead.\r\n\t\treturn true\r\n\t})\r\n}"]}