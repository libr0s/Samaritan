{"version":3,"sources":["../source/cldr.js"],"names":["parseCLDR","units","short","narrow","data","locale","Object","keys","main","timeUnitsFormattingRules","dates","fields","filter","unit","indexOf","parseUnit","reduce","localeData","_unit","type","setUnitRules","parseCLDRTimeUnitFormattingRules","rulesCLDR","rules","previous","current","next","past","quantifier","replace","other","length","future","now","test"],"mappings":"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","file":"cldr.js","sourcesContent":["// import { isEqual } from 'lodash'\r\n\r\n// The generic time measurement units.\r\n// (other units like \"fri\" or \"thu\" are ignored)\r\n// (\"quarter\" is required by `Intl.RelativeTimeFormat`)\r\nexport const units = ['second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year']\r\n\r\n// Detects short and narrow flavours of labels (yr., mo., etc).\r\n// E.g. there are \"month\", \"month-short\", \"month-narrow\".\r\n// More on \"narrow\" vs \"short\":\r\n// http://cldr.unicode.org/translation/plurals#TOC-Narrow-and-Short-Forms\r\nconst short = /-short$/\r\nconst narrow = /-narrow$/\r\n\r\n// Converts locale data from CLDR format to this library's format.\r\n//\r\n// CLDR locale data example:\r\n//\r\n// ```json\r\n// {\r\n//   \"main\": {\r\n//     \"en-US-POSIX\": {\r\n//       \"identity\": {\r\n//         \"language\": \"en\",\r\n//         ...\r\n//       },\r\n//       \"dates\": {\r\n//         \"fields\": {\r\n//           \"year\": {\r\n//             \"displayName\": \"year\",\r\n//             \"relative-type--1\": \"last year\",\r\n//             \"relative-type-0\": \"this year\",\r\n//             \"relative-type-1\": \"next year\",\r\n//             \"relativeTime-type-future\": {\r\n//               \"relativeTimePattern-count-one\": \"in {0} year\",\r\n//               \"relativeTimePattern-count-other\": \"in {0} years\"\r\n//             },\r\n//             \"relativeTime-type-past\": {\r\n//               \"relativeTimePattern-count-one\": \"{0} year ago\",\r\n//               \"relativeTimePattern-count-other\": \"{0} years ago\"\r\n//             }\r\n//           },\r\n// ...\r\n// ```\r\n//\r\n// Parsed locale data example:\r\n//\r\n// ```json\r\n// {\r\n// \t\"long\":\r\n// \t{\r\n// \t\t...\r\n// \t\t\"second\": [\r\n// \t\t\t{\r\n// \t\t\t\t\"one\": \"a second ago\",\r\n// \t\t\t\t\"other\": \"{0} seconds ago\"\r\n// \t\t\t},\r\n// \t\t\t{\r\n// \t\t\t\t\"one\": \"in a second\",\r\n// \t\t\t\t\"other\": \"in {0} seconds\"\r\n// \t\t\t}\r\n// \t\t],\r\n// \t\t...\r\n// \t},\r\n// \t\"short\":\r\n// \t{\r\n// \t\t...\r\n// \t},\r\n// \t...\r\n// }\r\n// ```\r\nexport default function parseCLDR(data)\r\n{\r\n\t// Extract `locale` from CLDR data\r\n\tconst locale = Object.keys(data.main)[0]\r\n\tconst timeUnitsFormattingRules = data.main[locale].dates.fields\r\n\r\n\treturn Object.keys(timeUnitsFormattingRules)\r\n\t.filter((unit) =>\r\n\t{\r\n\t\t// Take only the generic time measurement units\r\n\t\t// (skip exotic ones like \"fri\" on \"thu\").\r\n\t\treturn units.indexOf(parseUnit(unit).unit) >= 0\r\n\t})\r\n\t.reduce((localeData, _unit) =>\r\n\t{\r\n\t\tconst { unit, type } = parseUnit(_unit)\r\n\t\treturn setUnitRules(localeData, type, unit, parseCLDRTimeUnitFormattingRules(timeUnitsFormattingRules[_unit]))\r\n\t},\r\n\t// Parsed locale data\r\n\t{})\r\n}\r\n\r\n/**\r\n * Parses CLDR time unit formatting rules.\r\n * @param  {object} - CLDR time unit formatting rules.\r\n * @return {(object|string)}\r\n */\r\nfunction parseCLDRTimeUnitFormattingRules(rulesCLDR)\r\n{\r\n\tlet rules = {}\r\n\r\n\t// \"relative\" values aren't suitable for \"ago\" or \"in a\" cases,\r\n\t// because \"1 year ago\" != \"last year\" (too vague for Jan 30th)\r\n\t// and \"in 0.49 years\" != \"this year\" (it could be Nov 30th).\r\n\t// Still including them here for `Intl.RelativeTimeFormat` polyfill.\r\n\r\n\t// \"yesterday\"\r\n\tif (rulesCLDR['relative-type--1']) {\r\n\t\trules.previous = rulesCLDR['relative-type--1']\r\n\t}\r\n\r\n\t// \"today\"\r\n\t/* istanbul ignore else */\r\n\tif (rulesCLDR['relative-type-0']) {\r\n\t\trules.current = rulesCLDR['relative-type-0']\r\n\t}\r\n\r\n\t// \"tomorrow\"\r\n\tif (rulesCLDR['relative-type-1']) {\r\n\t\trules.next = rulesCLDR['relative-type-1']\r\n\t}\r\n\r\n\t// Formatting past times.\r\n\t//\r\n\t// E.g.:\r\n\t//\r\n\t// \"relativeTime-type-past\":\r\n\t// {\r\n\t// \t\"relativeTimePattern-count-one\": \"{0} mo. ago\",\r\n\t// \t\"relativeTimePattern-count-other\": \"{0} mo. ago\"\r\n\t// }\r\n\t//\r\n\t/* istanbul ignore else */\r\n\tif (rulesCLDR['relativeTime-type-past'])\r\n\t{\r\n\t\tconst past = rulesCLDR['relativeTime-type-past']\r\n\t\trules.past = {}\r\n\r\n\t\t// Populate all quantifiers (\"one\", \"other\", etc).\r\n\t\tfor (const quantifier of Object.keys(past)) {\r\n\t\t\trules.past[quantifier.replace('relativeTimePattern-count-', '')] = past[quantifier]\r\n\t\t}\r\n\r\n\t\t// Delete all duplicates of \"other\" rule.\r\n\t\tfor (const quantifier of Object.keys(rules.past)) {\r\n\t\t\tif (quantifier !== 'other' && rules.past[quantifier] === rules.past.other) {\r\n\t\t\t\tdelete rules.past[quantifier]\r\n\t\t\t}\r\n\t\t}\r\n\r\n \t\t// If only \"other\" rule is present then \"rules\" is not an object and is a string.\r\n\t\tif (Object.keys(rules.past).length === 1) {\r\n\t\t\trules.past = rules.past.other\r\n\t\t}\r\n\t}\r\n\r\n\t// Formatting future times.\r\n\t//\r\n\t// E.g.:\r\n\t//\r\n\t// \"relativeTime-type-future\":\r\n\t// {\r\n\t// \t\"relativeTimePattern-count-one\": \"in {0} mo.\",\r\n\t// \t\"relativeTimePattern-count-other\": \"in {0} mo.\"\r\n\t// }\r\n\t//\r\n\t/* istanbul ignore else */\r\n\tif (rulesCLDR['relativeTime-type-future'])\r\n\t{\r\n\t\tconst future = rulesCLDR['relativeTime-type-future']\r\n\t\trules.future = {}\r\n\r\n\t\t// Populate all quantifiers (\"one\", \"other\", etc).\r\n\t\tfor (const quantifier of Object.keys(future)) {\r\n\t\t\trules.future[quantifier.replace('relativeTimePattern-count-', '')] = future[quantifier]\r\n\t\t}\r\n\r\n\t\t// Delete all duplicates of \"other\" rule.\r\n\t\tfor (const quantifier of Object.keys(rules.future)) {\r\n\t\t\tif (quantifier !== 'other' && rules.future[quantifier] === rules.future.other) {\r\n\t\t\t\tdelete rules.future[quantifier]\r\n\t\t\t}\r\n\t\t}\r\n\r\n \t\t// If only \"other\" rule is present then \"rules\" is not an object and is a string.\r\n\t\tif (Object.keys(rules.future).length === 1) {\r\n\t\t\trules.future = rules.future.other\r\n\t\t}\r\n\t}\r\n\r\n\t// // If `.past` === `.future` then replace them with `.other`.\r\n\t// // (only eligible for \"tiny\" and \"*-time\" locale data which is not part of CLDR)\r\n\t// if (isEqual(rules.past, rules.future)) {\r\n\t// \trules.other = rules.past\r\n\t// \tdelete rules.future\r\n\t// }\r\n\r\n\t// // If only \"other\" rule is defined for a time unit\r\n\t// // then make \"rules\" a string rather than an object.\r\n\t// if (Object.keys(rules).length === 1) {\r\n\t// \trules = rules.other\r\n\t// }\r\n\r\n\treturn rules\r\n}\r\n\r\n/**\r\n * Sets time unit formatting rules in locale data.\r\n * @param {object} localeData\r\n * @param {string} type\r\n * @param {string} unit\r\n * @param {object} rules\r\n * @return {object} Locale data.\r\n */\r\nfunction setUnitRules(localeData, type, unit, rules)\r\n{\r\n\tif (!localeData[type]) {\r\n\t\tlocaleData[type] = {}\r\n\t}\r\n\r\n\tlocaleData[type][unit] = rules\r\n\r\n\t// Populate \"now\" unit rules.\r\n\tif (unit === 'second' && rules.current) {\r\n\t\tlocaleData[type].now = rules.current\r\n\t}\r\n\r\n\treturn localeData\r\n}\r\n\r\n/**\r\n * Parses CLDR time unit into `unit` and `type`.\r\n * @param  {string} CLDR_unit\r\n * @return {object} `{ type, unit }`.\r\n */\r\nfunction parseUnit(unit)\r\n{\r\n\tif (narrow.test(unit)) {\r\n\t\treturn { type: 'narrow', unit: unit.replace(narrow, '') }\r\n\t}\r\n\tif (short.test(unit)) {\r\n\t\treturn { type: 'short', unit: unit.replace(short, '') }\r\n\t}\r\n\treturn { type: 'long', unit }\r\n}"]}